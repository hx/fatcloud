package Skins {		import flash.display.*;	import Skins.*;	import flash.geom.*;	import flash.events.MouseEvent;	import flash.utils.*;		public class Wordle extends FatCloudSkin {				// Constants:		// Public Properties:		// Private Properties:				private var canvas:Sprite;		private var primer:Sprite;		private var options:Object;		private var tags:Array;		private var tagSeq:Array;		private var debug:Function;				private var font:String;		private var colorScheme:Array;				private var selector:Sprite;		private var selectorInner:Sprite;		private var selectorStartRect:Rectangle;		private var selectorStartAngle:Number;		private var selectorStartAlpha:Number;		private var selectorPhase:Number;		private var selectorPhaseSeed:Number;		private var selectorInterval:uint=0;				private var focusIndex:int=-1;				private var wTags:Array;				private var cache;			// Initialization:		public function Wordle() {			options=FatCloud.options;			debug=FatCloud.debug;			font=options.font;			cache=getSkinCache();			if(options.randomFont=='Yes') font=cache?cache.font:FatCloud.fonts[Math.floor(Math.random()*FatCloud.fonts.length)];			tags=[];			var ind:Array=[];			tagSeq=[];			for(var i:uint=0;i<FatCloud.tags.length;i++) ind.push(i);			while(ind.length) {				i=cache?cache.tagSeq[FatCloud.tags.length-ind.length]:Math.floor(Math.random()*ind.length);				tagSeq.push(i);				tags.push(FatCloud.tags[ind[i]]);				ind.splice(i,1);			}			addEventListener(DOMTagEvent.FOCUS, receiveDOMTagEvent);			addEventListener(DOMTagEvent.BLUR, receiveDOMTagEvent);		}			// Public Methods:				public function render() {			if(!this.firstRender) this.setup();		}				// Protected Methods:				private function setup() {						var i, j, tag:Object, wTag:WordleTag, ang:Number, col:Boolean, sib, rad:Number, circ:Number;			var pass:uint=0, dir:Boolean=false, radians:Number, angOff:Number=0, retX:int=0, retY=0;						wTags=[];						var sw:Number=stage.stageWidth;			var sh:Number=stage.stageHeight;						var angularPrecision:Number=2;			var radialPrecision:Number=2;							// colors						colorScheme=[0xFFFFFF, 0];						if(options.colorScheme=='Custom') {				colorScheme=[					FatCloud.colorVal(options.fgColor),					FatCloud.colorVal(options.mgColor),					FatCloud.colorVal(options.sColor),					FatCloud.colorVal(options.bgColor)				];			} else if(options.colorScheme=='Random') {				var sNames:Array=[];				for(i in schemes) sNames.push(i);				colorScheme=schemes[sNames[Math.floor(Math.random()*sNames.length)]];			} else if(options.colorScheme in schemes) colorScheme=schemes[options.colorScheme];							// draw background									with(graphics) {				clear();				beginFill(getColor());				drawRect(0,0,sw,sh);				endFill();			}						// create canvas						canvas=new Sprite();									var requiredSurfaceArea:Number=0;			var availableSurfaceArea:Number=sw*sh;						for(i=0;i<tags.length;i++) requiredSurfaceArea+=getSurfaceArea(tags[i]);									var d:Boolean=false;						for(i=0;i<tags.length;i++) {								tag=tags[i];								wTag=new WordleTag();				wTag.index=wTags.length;				wTags.push(wTag);				wTag.label=tag.label;				wTag.font=font;				wTag.color=getColor(tag);				wTag.angle=cache?cache.tags[i][0]:getRandomAngle();				wTag.render();				if(cache) wTag.size=cache.tags[i][3];				else wTag.size*=Math.sqrt((getSurfaceArea(tag)/requiredSurfaceArea)*(availableSurfaceArea/wTag.surfaceArea()));				wTag.render();								canvas.addChild(wTag);								if(cache) {					wTag.x=cache.tags[i][1];					wTag.y=cache.tags[i][2];				} else {									wTag.x=sw/2;					wTag.y=sh/2;						for(j=0;j<canvas.numChildren-1;j++) {						sib=canvas.getChildAt(j);						if(sib.width<wTag.width&&sib.height<wTag.height) {							wTag.x=sib.x;							wTag.y=sib.y;						}					}										rad=Math.sqrt(Math.pow((2*wTag.x-sw)/sw,2)+Math.pow((2*wTag.y-sh)/sh,2));					angOff=Math.atan2(wTag.y-sh/2,wTag.x-sw/2)*180/Math.PI;					ang=0;										dir=Math.random()<0.5?true:false;										if(d) with(canvas.graphics) {						moveTo(wTag.x, wTag.y);						lineStyle(1,0xFFFF00);						beginFill(0xFF);					}										if(canvas.numChildren>1) do {												circ=rad*(sw+sh)*Math.PI/2;																	ang+=Math.min(360,wTag.size/circ*360/angularPrecision);												if(ang>=360) {							ang-=360;							rad+=wTag.size/Math.min(sh,sw)/radialPrecision;							angOff=Math.random()*360;						}												radians=(((dir?ang:360-ang)+angOff)%360)*Math.PI/180;												if(d) canvas.graphics.moveTo(wTag.x, wTag.y);												wTag.x=sw/2+Math.cos(radians)*sw*rad/2;						wTag.y=sh/2+Math.sin(radians)*sh*rad/2;												if(d) with (canvas.graphics) {							lineTo(wTag.x,wTag.y);							drawCircle(wTag.x, wTag.y, 3);						}																					} while(checkLastTagProximity());										retX=wTag.x<sw/2?1:-1;					retY=wTag.y<sh/2?1:-1;										while(retX!=0||retY!=0) {						wTag.x+=retX;						if((retX==1&&wTag.x>=sw/2)||(retX==-1&&wTag.x<=sw/2)) retX=0;						else if(checkLastTagProximity()) {							wTag.x-=retX;							retX=0;						}						wTag.y+=retY;						if((retY==1&&wTag.y>=sh/2)||(retY==-1&&wTag.y<=sh/2)) retY=0;						else if(checkLastTagProximity()) {							wTag.y-=retY;							retY=0;						}					}										if(d) with(canvas.graphics) {						endFill();						lineStyle();					}				}			}						addChild(canvas);						var cBounds:Rectangle=canvas.getBounds(this);			var sX=sw/cBounds.width;			var sY=sh/cBounds.height;						sX=sY=Math.min(sX,sY);						canvas.x-=cBounds.x*sX;			canvas.y-=cBounds.y*sY;			canvas.scaleX=sX;			canvas.scaleY=sY;						canvas.y+=(sh-canvas.height)/2;			canvas.x+=(sw-canvas.width)/2;									selector=new Sprite();			selectorInner=new Sprite();			canvas.addChild(selector);			selector.addChild(selectorInner);			canvas.swapChildren(canvas.getChildAt(0),selector);						selector.alpha=0;			var bg:uint=getColor();			var bgRGB:Array=[(bg&0xFF0000)<<16,(bg&0xFF00)<<8,bg&0xFF];			var bgLum:Number=(Math.max(bgRGB[0],bgRGB[1],bgRGB[2])+Math.min(bgRGB[0],bgRGB[1],bgRGB[2]))/2;						with(selectorInner.graphics) {				beginFill(getColor(true));				//drawRect(-10,-10, 20, 20);				drawRoundRect(-10,-10,20,20,5,5);				endFill();			}						primer=new Sprite();			canvas.addChild(primer);						var primerBounds:Rectangle=getBounds(canvas);			with(primer.graphics) {				beginFill(0,0);				drawRect(primerBounds.x, primerBounds.y, primerBounds.width, primerBounds.height);				endFill();			}						primer.buttonMode=primer.useHandCursor=true;						primer.addEventListener(MouseEvent.MOUSE_DOWN, function(e:MouseEvent) {				var f=focusIndex;				if(f<0) f=lastFocus;				//debug(f);				for(i=0;i<tags.length;i++) if(FatCloud.tags[i]==tags[f]) {					tagSelect(i);				}			});			primer.addEventListener(MouseEvent.MOUSE_MOVE, function(e:MouseEvent) {				//				var range:Number=(canvas.width+canvas.height)/10;				var distance:Number, scale:Number;				var wTag:WordleTag;								var hoverred:Array=[];								for(var i=0;i<wTags.length;i++) {										wTag=wTags[i];										if(wTag.mouseIsOver()) hoverred.push(wTag);										distance=Math.sqrt(Math.pow(e.localX-wTag.x,2)+Math.pow(e.localY-wTag.y,2));										// disabled the fishbowl effect because text wobbled too much.										/*if(distance<range) {												distance/=range;						scale=Math.cos(distance*0.5*Math.PI)*Math.pow(1-distance,0.25);												wTag.scaleX = wTag.scaleY = scale > 0 ? 1+(scale*(maxScale-1)) : minScale+(scale*(1-minScale));											} else wTag.scaleX=wTag.scaleY=1;*/									}								var focussed:WordleTag=null;				if(hoverred.length) {					focussed=hoverred[0];					if(hoverred.length>1) for(i=1;i<hoverred.length;i++) {						if(Math.sqrt(Math.pow(hoverred[i].x-canvas.mouseX,2)+Math.pow(hoverred[i].y-canvas.mouseY,2))						< Math.sqrt(Math.pow(focussed.x-canvas.mouseX,2)+Math.pow(focussed.y-canvas.mouseY,2)))							focussed=hoverred[i];					}				}								var bounds:Rectangle;				if(focussed) {					giveFocus(focussed);					if(selectorInterval==0) setSelectorSize();					for(i=0;i<tags.length;i++) if(FatCloud.tags[i]==tags[focussed.index]) tagFocus(i);				} else {					if(focusIndex>=0) for(i=0;i<tags.length;i++) if(FatCloud.tags[i]==tags[focusIndex]) tagBlur(i);					giveFocus();				}							});						if(!cache) this.exportSkinCache();		}				private function exportSkinCache() {			var cache={				'font':font,				'tagSeq':tagSeq,				'tags':[]			};			for(var i=0;i<wTags.length;i++) cache.tags.push([wTags[i].angle,wTags[i].x,wTags[i].y,wTags[i].size]);			setSkinCache(cache);		}				var lastFocus:uint=0;		function receiveDOMTagEvent(e:DOMTagEvent) {			if(e.type==DOMTagEvent.BLUR) {				lastFocus=focusIndex;				giveFocus();				return;			} else if(e.type==DOMTagEvent.FOCUS) {				var wTag:WordleTag, i:uint;				for(i=0;i<tags.length;i++) if(tags[i]==e.tag) wTag=wTags[i];				giveFocus(wTag);			}		}				private function giveFocus(wTag:WordleTag=null):void {			if(wTag===null) {				if(focusIndex==-1) return;				focusIndex=-1;			} else {				if(wTag.index==focusIndex) return;				focusIndex=wTag.index;				selectorStartRect=new Rectangle;				selectorStartRect.x=selector.x;				selectorStartRect.y=selector.y;				selectorStartRect.width=selectorInner.width;				selectorStartRect.height=selectorInner.height;				selectorStartAngle=selector.rotation;			}			selectorStartAlpha=selector.alpha;			selectorPhaseSeed=selectorPhase=0;			if(focusIndex>=1&&selector.alpha==0) selectorPhaseSeed=selectorPhase=1;			if(selectorInterval==0) selectorInterval=setInterval(selectorStep,40);					}				private function selectorStep() {						selectorPhaseSeed=Math.max(Math.min(selectorPhaseSeed+0.15,1),0);						selectorPhase=Math.pow(selectorPhaseSeed,0.3);						selector.alpha=selectorStartAlpha+((focusIndex==-1?0:1)-selectorStartAlpha)*selectorPhaseSeed;						if(focusIndex>=0) {								var wTag:WordleTag=wTags[focusIndex];				var bounds:Rectangle=wTag.textBounds();								selector.rotation=selectorStartAngle+(wTag.angle-selectorStartAngle)*selectorPhase;								selector.x=selectorStartRect.x+(wTag.x-selectorStartRect.x)*selectorPhase;				selector.y=selectorStartRect.y+(wTag.y-selectorStartRect.y)*selectorPhase;								setSelectorSize();							}						if(selectorPhaseSeed==1) {				clearInterval(selectorInterval);				selectorInterval=0;			}		}				private function setSelectorSize():void {			if(focusIndex==-1) return;			var wTag:WordleTag=wTags[focusIndex];			var bounds:Rectangle=wTag.textBounds();			var tw:Number=bounds.width*1.1*wTag.scaleX;			var th:Number=bounds.height*1.1*wTag.scaleY;			selectorInner.width=selectorStartRect.width+(tw-selectorStartRect.width)*selectorPhase;			selectorInner.height=selectorStartRect.height+(th-selectorStartRect.height)*selectorPhase;		}						private static var minScale:Number=0.97;		private static var maxScale:Number=1.1;				private function getSurfaceArea(tag:Object) {			return tag.label.length*Math.pow(1+(tag.scale*(Math.sqrt(options.sizeRatio)-1)),2);		}						// use [biggest, ... , smallest, selector, background]				private static var schemes:Object={			'Aqua':		[0x0d47a9, 0x5594c1, 0x87cfdc, 0xffffff, 0xdaf1fb],			'Dessert':	[0xfcf29e, 0xffa4a4, 0xfcc058, 0x630075, 0x820099]		};				private function getColor(tag=null):uint {						if(tag===null) return colorScheme[colorScheme.length-1];			if(tag===true) return colorScheme[colorScheme.length-2];			if(colorScheme.length==3) return colorScheme[0];						var index:Number=(1-tag.scale)*(colorScheme.length-3);			if(index==Math.floor(index)) return colorScheme[index];						var f:Number=index-Math.floor(index);						var l:Number=colorScheme[Math.floor(index)];			var h:Number=colorScheme[Math.ceil(index)];						var la:Array=[(l&0xFF0000)>>16,(l&0xFF00)>>8,l&0xFF];			var ha:Array=[(h&0xFF0000)>>16,(h&0xFF00)>>8,h&0xFF];						var a:Array=[];			var off=Math.random()*50-25;			for(var i=0;i<3;i++) a[i]=Math.floor(Math.max(Math.min(la[i]+(ha[i]-la[i])*f+off,255),0));						return (a[0]<<16)|(a[1]<<8)|a[2];					}				private var randomAngle:Number=-1;		private function getRandomAngle() {			var aspect:Number=stage.stageWidth/stage.stageHeight;			switch(options.textAngle) {				case 'Horizontal': return 0;				case 'Vertical': return 270;				case '45 Degrees': return Math.random()>=0.5 ? 45 : 315;				case 'Horizontal/Vertical': return Math.random()<1-(1/(aspect+1)) ? 0 : 270;								}			if(randomAngle==-1||options.textAngle=='Random (all different)') {				randomAngle=Math.pow(Math.random(),aspect)*90;				randomAngle=Math.random()>=0.5 ? randomAngle : 360-randomAngle;			}			return randomAngle;		}			private function checkLastTagProximity() {			if(canvas.numChildren<2) return false;			for(var i=0;i<canvas.numChildren-1;i++) if(checkProximity(canvas.getChildAt(canvas.numChildren-1),canvas.getChildAt(i),4)) return true;			return false;		}			private function checkProximity(objA:DisplayObject, objB:DisplayObject, padding:Number=0) {						if(objB.parent!==objA.parent) return false;						var boundsA:Rectangle=objA.getBounds(objA.parent);			var boundsB:Rectangle=objB.getBounds(objB.parent);						if(padding>0) {				boundsA.width+=padding*2;				boundsA.height+=padding*2;				boundsA.x-=padding;				boundsA.y-=padding;				boundsB.width+=padding*2;				boundsB.height+=padding*2;				boundsB.x-=padding;				boundsB.y-=padding;			}						if(!boundsA.intersects(boundsB)) return false;						var bounds:Rectangle=boundsA.intersection(boundsB);			if(bounds.width<1||bounds.height<1) return false;						var alphaA:BitmapData=alphaRep(objA, bounds, BitmapDataChannel.RED);			var alphaB:BitmapData=alphaRep(objB, bounds, BitmapDataChannel.GREEN);							var stamps:Array=[[padding,padding]];			if(padding>0) {				stamps.push([padding,-padding]);				stamps.push([-padding,padding]);				stamps.push([-padding,-padding]);			}						var m:Matrix;			for(var i=0;i<stamps.length;i++) {				m=new Matrix();				m.translate(stamps[i][0],stamps[i][1]);				alphaA.draw(alphaB, m, new ColorTransform(), BlendMode.LIGHTEN);			}									return alphaA.getColorBoundsRect(0x808000,0x808000).size.length>0;					}				private function alphaRep(obj:DisplayObject,bounds:Rectangle,channel:uint) {						var m:Matrix=new Matrix();			m.translate(obj.x-bounds.x,obj.y-bounds.y);						var bm:BitmapData=new BitmapData(bounds.width, bounds.height, true, 0);			bm.draw(obj,m);						var ret:BitmapData=new BitmapData(bounds.width,bounds.height,false,0);			ret.copyChannel(bm,bm.rect,new Point(0,0),BitmapDataChannel.ALPHA,channel);			return ret;					}	}	}